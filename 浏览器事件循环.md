# 浏览器事件循环

## 微任务产生原因
  宏任务的时间粒度比较大，执行的时间间隔是不能精确控制的，对一些高实时性的需求就不太符合了，比如后面要介绍的监听 DOM 变化的需求。

  不过要搞清楚微任务系统是怎么运转起来的，就得站在 V8 引擎的层面来分析下。我们知道当 JavaScript 执行一段脚本的时候，V8 会为其创建一个**全局执行上下文**，
在创建全局执行上下文的同时，V8 引擎也会在内部创建一个**微任务队列**。顾名思义，这个微任务队列就是用来存放微任务的，因为在当前宏任务执行的过程中，有时候会产生多个微任务，
这时候就需要使用这个微任务队列来保存这些微任务了。不过这个微任务队列是给 V8 引擎内部使用的，所以你是无法通过 JavaScript 直接访问的。

  现在微任务队列中有了微任务了，那接下来就要看看微任务队列是何时被执行的。通常情况下，在当前宏任务中的 JavaScript 快执行完成时，
也就在 JavaScript 引擎准备退出全局执行上下文并清空调用栈的时候，JavaScript 引擎会检查全局执行上下文中的微任务队列，然后按照顺序执行队列中的微任务。
WHATWG 把执行微任务的时间点称为检查点。当然除了在退出全局执行上下文式这个检查点之外，还有其他的检查点，不过不是太重要，这里就不做介绍了。
如果在执行微任务的过程中，产生了新的微任务，同样会将该微任务添加到微任务队列中，V8 引擎一直循环执行微任务队列中的任务，直到队列为空才算执行结束。
也就是说在执行微任务过程中产生的新的微任务并不会推迟到下个宏任务中执行，而是在当前的宏任务中继续执行。

任务队列分为macrotask（宏任务）与microtask（微任务）

开始解释**事件循环**的流程，当执行栈为空时，事件循环先从一个macro-task开始，然后执行所有的micro-task，再执行一个macro-task，balabala...

那么问题来了，在第一次执行事件循环的时候，通常都会这样说

事件循环从宏任务队列开始，这个时候，宏任务队列中，只有一个script(整体代码)任务。
```
(function test() {
    setTimeout(function() {console.log(4)}, 0);
    new Promise(function executor(resolve) {
        console.log(1);
        for( var i=0 ; i<10000 ; i++ ) {
            i == 9999 && resolve();
        }
        console.log(2);
    }).then(function() {
        console.log(5);
    });
    console.log(3);
})()
```
直接说说macrotasks和microtasks的执行顺序吧：

主js作为macro先入队列，编号ma1
执行到setTimeout...，回调作为macro入队列，编号ma2
执行到new Promise...，then作为micro入队列，编号mi1
ma1执行完之前，调用mi1，mi1执行完以后，ma1也就正式的结束了
ma2开始执行
可以认为macro是主人，micro是奴隶，哪个macro创建了micro，micro就管它叫主人。

总的来说就是，**macro作为主导，它有支配micro的能力**，在一个macro任务消灭之前，它会让它创建的micro任务都执行完，然后才进入下一个macro任务。

## JS宏任务,微任务分类
**浏览器**
### 1.宏任务
setTimeout  
setInterval  
requestAnimationFrame

### 2.微任务
MutationObserver  
Promise.then catch finally  


## 一、浏览器事件循环

浏览器中的 js 执行是单线程，但是比如我们发送的一个 ajax 请求为什么可以异步执行？因为浏览器中的事件循环机制，可以一边执行同步任务，一边处理异步任务。

同步任务进入主线程，异步的进入 Event Table 并注册回调函数，异步逻辑执行完将回调函数移入 Event Queue 队列。

主线程内的任务执行完毕为空（会持续不断的检查主线程执行栈是否为空）就会去 Event Queue 读取对应的函数，放进主线程执行。

这个不断重复的过程就被称为 Event Loop (事件循环)。
![image](https://user-images.githubusercontent.com/24501320/111964523-a8ffeb00-8b2f-11eb-9537-3169a2ca514f.png)

大致的了解什么是事件循环，并且知道异步会被进入一个异步事件注册回调，但是 js 中还有微任务的概念。

**macro-task（宏任务）**：setTimeout、setInterval、setImmediate、全部代码、 I/O 操作、UI 渲染等

**micro-task（微任务）**:  process.nextTick、Promise、MutationObserver(html5 新特性) 等

那么这个过程中微任务和宏任务的运行和事件循环有什么关系呢
![image](https://user-images.githubusercontent.com/24501320/111964560-b4531680-8b2f-11eb-8cf8-b155653b770c.png)

```
let timer1 = setTimeout(()=>{
    console.log('1')
    Promise.resolve().then(()=>{
        console.log('1-1')
        Promise.resolve().then(()=>{
            console.log('1-1-1')
        })
    })
    Promise.resolve().then(()=>{
	console.log('1-2')
	let timer3 = setTimeout(()=>{
            console.log('1-2-1')
             Promise.resolve().then(()=>{
                console.log('1-2-2')
            })
        }, 0)
    })
}, 0)

let timer2 = setTimeout(()=>{
    console.log('2')
    Promise.resolve().then(()=>{
        console.log('2-1')
    })
}, 0)

Promise.resolve().then(()=>{
    console.log('3')
    Promise.resolve().then(()=>{
        console.log('3-1')
    })
})

//结果 3、3-1、1、1-1、 1-2、1-1-1、2、2-1、1-2-1、1-2-2
```
# 总结：
在第一个定时器中将所有的微任务执行完才会进行第二个 timer2 的执行，同时 timer1 中又注册了一个 timer3 宏任务，最后再会被执行。所以我们可以得出一个结论：
**宏任务队列可以有多个，微任务队列只有一个**。所以上图中标注的是有可执行的微任务并且执行所有。

补充：js 或者 node 中的定时器并不是严格的到点就执行，只是到点会把任务放进 Event Queue，具体执不执行这个回调要看主线程有没有空闲（没有正在处理的任务了），
比如通过耗时的 while 循环等操作，会影响定时器回调的延迟执行，所以不要相信定时器。
